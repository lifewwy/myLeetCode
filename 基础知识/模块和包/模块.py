
# 模块，在Python可理解为对应于一个文件。
# 在创建了一个脚本文件后，定义了某些函数和变量。
# 你在其他需要这些功能的文件中，导入这模块，就可重用这些函数和变量。
# 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。
# 模块可以被别的程序引入，以使用该模块中的函数等功能。

# import 语句
# 想使用 Python 源文件，只需在另一个源文件里执行 import 语句
# 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
# 搜索路径是一个解释器会先进行搜索的所有目录的列表。
# sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。

# 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。
# 当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？
# 这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，
# Python解释器就依次从这些目录中去寻找所引入的模块。
# 这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。
# 搜索路径被存储在sys模块中的path变量中

import fibo
fibo.fib(1000)

# 如果你打算经常使用一个函数，你可以把它赋给一个本地的名称
fib = fibo.fib
fib(500)

# ---------------------------------------------------------------------------------------------------------------------
# __name__属性
# 一个模块被另一个程序第一次引入时，其主程序将运行。
# 如果我们想在模块被引入时，模块中的某一程序块不执行，
# 我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。


# Python使用缩进对齐组织代码的执行，所有没有缩进的代码，都会在载入时自动执行。
# 每个文件（模块）都可以任意写一些没有缩进的代码，并在载入时自动执行。
# 为了区分 主执行代码和被调用文件，Python引入了变量：__name__。
# 1）当文件是被调用时，__name__的值为模块名；
# 2）当文件自身被执行时，__name__的值为 '__main__'。
# 基于此特性，为测试驱动开发提供了很好的支持，我们可以在每个模块中写上测试代码，
# 这些测试代码仅当模块被Python直接执行时才会运行，代码和测试完美的结合在一起。

import using_name

print( using_name.__name__)

# ---------------------------------------------------------------------------------------------------------------------
# dir() 函数
# 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:
import fibo
print( dir(fibo) )

# 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称，
# 包括所有引入模块内定义的名称
import fibo
a = [1, 2, 3, 4, 5]
if True:
    b = 10
def myfunc():
    c = 100

print( dir() )






